# Fetch Tab Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a Fastfetch-first Fetch tab with preset browsing, preview execution, and persisted defaults in the existing GTK3 + Glade app.

**Architecture:** Add a dedicated `FetchService` backend that discovers presets and runs preview commands safely, then wire a Glade-based `page_fetch` UI in `main.py` using the same card and status patterns as existing tabs. Persist user choices in a new `fetch` settings section and keep engine support extensible so Neofetch can be added without redesign.

**Tech Stack:** Python 3.14, PyGObject/GTK3 (3.24), Glade 3.40, JSON settings store, subprocess for command execution, pytest for backend tests.

---

Implementation notes:
- Follow `@test-driven-development` for each behavior slice.
- Run final checks with `@verification-before-completion`.

### Task 1: Add fetch backend service and data models

**Files:**
- Create: `backend/fetch.py`
- Modify: `backend/__init__.py`
- Test: `tests/backend/test_fetch_service.py`

**Step 1: Write the failing test**

```python
from pathlib import Path

from backend.fetch import FetchService
from backend.settings import SettingsStore


def test_list_fastfetch_presets_reads_json_and_jsonc(tmp_path: Path):
    base = tmp_path / "app"
    presets_dir = base / "library" / "fetch" / "fastfetch"
    presets_dir.mkdir(parents=True)
    (presets_dir / "minimal.json").write_text('{"$schema":"x"}\n', encoding="utf-8")
    (presets_dir / "rice.jsonc").write_text('{"logo": {"padding": 2}}\n', encoding="utf-8")

    settings = SettingsStore(base / "settings.json")
    service = FetchService(base, settings)

    names = [p.name for p in service.list_presets("fastfetch")]
    assert names == ["minimal", "rice"]
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/backend/test_fetch_service.py::test_list_fastfetch_presets_reads_json_and_jsonc -v`
Expected: FAIL with `ModuleNotFoundError` or missing `FetchService`.

**Step 3: Write minimal implementation**

```python
# backend/fetch.py
from dataclasses import dataclass
from pathlib import Path


@dataclass
class FetchPreset:
    engine: str
    name: str
    path: Path


class FetchService:
    def __init__(self, base_dir: Path, settings):
        self.base_dir = Path(base_dir)
        self.settings = settings

    def list_presets(self, engine: str):
        root = self.base_dir / "library" / "fetch" / engine
        if not root.exists():
            return []
        exts = {".json", ".jsonc"} if engine == "fastfetch" else {".conf"}
        out = []
        for p in sorted(root.iterdir(), key=lambda x: x.name.lower()):
            if p.is_file() and p.suffix.lower() in exts:
                out.append(FetchPreset(engine=engine, name=p.stem, path=p))
        return out
```

**Step 4: Run test to verify it passes**

Run: `pytest tests/backend/test_fetch_service.py::test_list_fastfetch_presets_reads_json_and_jsonc -v`
Expected: PASS.

**Step 5: Commit**

```bash
git add backend/fetch.py backend/__init__.py tests/backend/test_fetch_service.py
git commit -m "feat(fetch): add preset discovery service"
```

### Task 2: Add settings defaults and engine tool detection wiring

**Files:**
- Modify: `backend/deps.py`
- Modify: `backend/fetch.py`
- Test: `tests/backend/test_fetch_service.py`

**Step 1: Write the failing test**

```python
def test_fetch_settings_defaults_created(tmp_path):
    from backend.fetch import FetchService
    from backend.settings import SettingsStore

    base = tmp_path / "app"
    settings = SettingsStore(base / "settings.json")
    service = FetchService(base, settings)

    section = service.get_fetch_section()
    assert section["engine"] == "fastfetch"
    assert isinstance(section["preset_dirs"], list)
    assert section["auto_refresh"] is True
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/backend/test_fetch_service.py::test_fetch_settings_defaults_created -v`
Expected: FAIL because defaults helper is missing.

**Step 3: Write minimal implementation**

```python
# in FetchService

def get_fetch_section(self):
    return self.settings.get_section(
        "fetch",
        default={
            "engine": "fastfetch",
            "preset_dirs": [],
            "default_preset": "",
            "search_text": "",
            "auto_refresh": True,
        },
    )
```

Also extend `detect_external_tools()` return map with:
- `fastfetch`
- `neofetch`
- `xdg_open`

**Step 4: Run test to verify it passes**

Run: `pytest tests/backend/test_fetch_service.py::test_fetch_settings_defaults_created -v`
Expected: PASS.

**Step 5: Commit**

```bash
git add backend/deps.py backend/fetch.py tests/backend/test_fetch_service.py
git commit -m "feat(fetch): persist fetch defaults and detect fetch binaries"
```

### Task 3: Build Glade UI for page_fetch

**Files:**
- Modify: `Archcrafter2.glade`
- Test: `Archcrafter2.glade` XML validity

**Step 1: Write the failing test/check**

Define expected object IDs list and validate via grep:
- `combo_fetch_engine`
- `chooser_fetch_preset_dir`
- `entry_fetch_search`
- `flowbox_fetch_presets`
- `textview_fetch_preview`
- `label_fetch_selected_path`
- `button_fetch_run_preview`
- `button_fetch_set_default`
- `button_fetch_open_file`
- `button_fetch_reveal_folder`
- `button_fetch_open_builder`

**Step 2: Run check to verify it fails**

Run: `rg -n "combo_fetch_engine|flowbox_fetch_presets|textview_fetch_preview" Archcrafter2.glade`
Expected: no matches before UI is added.

**Step 3: Write minimal implementation**

- Replace placeholder `page_fetch` content with:
  - title + subtitle
  - control row (engine, folder chooser, search, refresh)
  - horizontal paned/split: preset flowbox left, preview panel right
  - action row with buttons listed above
- Reuse existing CSS class names where possible.

**Step 4: Run check to verify it passes**

Run: `xmllint --noout Archcrafter2.glade`
Expected: success with no XML errors.

**Step 5: Commit**

```bash
git add Archcrafter2.glade
git commit -m "feat(fetch): add fetch tab layout in glade"
```

### Task 4: Wire Fetch tab behavior in main application

**Files:**
- Modify: `main.py`
- Test: `tests/ui/test_fetch_ui_state.py`

**Step 1: Write the failing test**

```python
def test_select_fetch_preset_updates_preview_text(tmp_path):
    # Build minimal app object with mock builder widgets,
    # call selection handler, assert preview buffer changed.
    assert False, "TODO: implement"
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/ui/test_fetch_ui_state.py::test_select_fetch_preset_updates_preview_text -v`
Expected: FAIL.

**Step 3: Write minimal implementation**

In `main.py`:
- Add fetch widget members in `__init__`.
- Add `init_fetch_page()` and call it from `do_activate()`.
- Connect signals:
  - engine changed
  - search changed
  - refresh clicked
  - run preview / set default / open / reveal / open builder
- Add helpers:
  - `reload_fetch_presets()`
  - `_render_fetch_preset_card(...)`
  - `_set_fetch_preview_text(...)`
  - `on_fetch_preset_selected(...)`
- Persist changes through `FetchService` + `SettingsStore`.

**Step 4: Run test to verify it passes**

Run: `pytest tests/ui/test_fetch_ui_state.py::test_select_fetch_preset_updates_preview_text -v`
Expected: PASS.

**Step 5: Commit**

```bash
git add main.py tests/ui/test_fetch_ui_state.py
git commit -m "feat(fetch): wire fetch tab interactions and persistence"
```

### Task 5: Add fetch-specific styling and full verification

**Files:**
- Modify: `assets/app.css`
- Test: `tests/backend/test_fetch_service.py`
- Test: `tests/ui/test_fetch_ui_state.py`

**Step 1: Write the failing test/check**

Add snapshot-like UI check notes for required style classes:
- `.fetch-preview-surface`
- `.fetch-engine-chip`
- `.fetch-action-row`

**Step 2: Run check to verify it fails**

Run: `rg -n "fetch-preview-surface|fetch-engine-chip|fetch-action-row" assets/app.css`
Expected: no matches before styles are added.

**Step 3: Write minimal implementation**

- Add only fetch-targeted CSS classes and avoid changing global selectors.
- Keep style consistent with existing card/pill/button language.

**Step 4: Run test/checks to verify pass**

Run:
- `python3 -m py_compile main.py backend/*.py`
- `xmllint --noout Archcrafter2.glade`
- `pytest tests/backend/test_fetch_service.py -v`
- `pytest tests/ui/test_fetch_ui_state.py -v`

Expected:
- compile and XML checks pass
- tests pass

**Step 5: Commit**

```bash
git add assets/app.css
git commit -m "style(fetch): add fetch tab styling"
```

### Task 6: Manual QA on live desktop session

**Files:**
- No code changes (manual verification checklist)

**Step 1: Run app**

Run: `python3 main.py`
Expected: app launches with functional Fetch tab.

**Step 2: Verify behavior**

- Switch to Fetch tab and confirm preset cards appear.
- Change engine and confirm list refreshes.
- Search by name and confirm filtering.
- Run preview and confirm output appears in preview pane.
- Set default preset, restart app, verify persistence.

Expected: all actions complete without traceback; status messages are informative.

**Step 3: Commit QA notes (optional if tracked)**

```bash
# Optional: if maintaining a QA log file
git add docs/
git commit -m "docs(fetch): record manual QA checklist results"
```
